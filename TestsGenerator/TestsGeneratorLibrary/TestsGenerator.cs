using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TestsGeneratorLibrary
{
    public class TestsGenerator
    {
        public async Task<TestClass> GenerateTest(string file)
        {
            SyntaxTree tree = CSharpSyntaxTree.ParseText(file);
            //string name = (tree.GetRoot().DescendantNodes().First(n => 
            //                n.IsKind(SyntaxKind.NamespaceDeclaration)) as NamespaceDeclarationSyntax).Name.ToString();
            //test.Name = name;
            //test.Name = "Test" + tree.FilePath.Substring(tree.FilePath.LastIndexOf("\\") + 1);
            //CancellationToken token = new CancellationToken(false);
            //var root = await tree.GetRootAsync();
            List<ClassDeclarationSyntax> classes = tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
            /*var root = tree.GetRoot();
            var classesRequest = root.DescendantNodes().Where(n => n.IsKind(SyntaxKind.ClassDeclaration));
            List<SyntaxNode> classes = classesRequest.ToList<SyntaxNode>();
            var methodsRequest = classes.SelectMany(n => n.DescendantNodes().Where(node => node.IsKind(SyntaxKind.MethodDeclaration)));
            List<SyntaxNode> methods = methodsRequest.Where(m => m.ChildTokens().Any(t => t.IsKind(SyntaxKind.PublicKeyword))).ToList<SyntaxNode>();
            */
            
            
            var methodBlock = new TransformBlock<MethodDeclarationSyntax, string>(async method => {
                string testMethod;
                testMethod = "\r\n";
                testMethod += "\t\t[TestMethod]\r\n";
                testMethod += "\t\t\tpublic void " + method.Identifier.ValueText + "Test()\r\n";
                testMethod += "\t\t\t{\r\n";
                testMethod += "\t\t\t\tAssert.Fail(\"autogenerated\");\r\n";
                testMethod += "\t\t\t}\r\n";
                return testMethod;
            });

            TestClass test = new TestClass();
            test.Name = "Test" + classes.First().Identifier.ValueText + ".cs";
            test.Text = "using System;\r\n";
            test.Text += "namespace MyCode.Tests\r\n";
            test.Text += "{\r\n";
            test.Text += "\t[TestClass]\r\n";
            test.Text += "\tpublic class " + test.Name.Substring(0, test.Name.IndexOf(".")) + "\r\n";
            test.Text += "\t{\r\n";

            foreach (var classDec in classes)
            {
                List<MethodDeclarationSyntax> methods = classDec.DescendantNodes()
                    .OfType<MethodDeclarationSyntax>().ToList().Where(method => method.Modifiers.ToList().Any(token => token.Text != "pivate")).ToList();
                
                foreach (var method in methods)
                {
                    await methodBlock.SendAsync(method);
                    /*test.Text += "\r\n";
                    test.Text += "\t\t[TestMethod]\r\n";
                    test.Text += "\t\t\tpublic void " + (method as MethodDeclarationSyntax).Identifier + "Test()\r\n";
                    test.Text += "\t\t\t{\r\n";
                    test.Text += "\t\t\t\tAssert.Fail(\"autogenerated\");\r\n";
                    test.Text += "\t\t\t}\r\n";*/
                }
                foreach (var method in methods)
                {
                    test.Text += await methodBlock.ReceiveAsync();
                }

                methodBlock.Complete();
                methodBlock.Completion.Wait();
            }
           
            /*
            foreach (var method in methods)
            {
                test.Text += methodBlock.Receive();
            }*/

            
            
            test.Text += "\t}\r\n";
            test.Text += "}";
            return test;
        }
    }
}
